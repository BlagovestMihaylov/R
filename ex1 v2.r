install.packages("UsingR")  #   Инсталиране на пакети




#       Преди да инсталираме пакети, желателно е да проверим дали пакетът вече не е инсталиран.
#   Това става с реда 
installed.packages()


#       Резултатът е матрица, която съдържа името на пакета, директорията на пакета, версията
# и т.н. Ако само се нуждаем от имената на инсталираните пакети, то най-добре е да изпозлваме
# командата по-долу
row.names(installed.packages()) 
#   Връща ни вектор с имената. Векторът може да се присвои на променлива


library("UsingR") #   Зареждане на пакета


#       - Как можем да потърсим помощ в R? 
#       - С помощта на ?името_на_функцията и help("името_на_функцията"). Ако не се сещаме 
#   името на функцията, която ни трябва, то можем да напишем част от това, която ни трябва
?mean
help("sd")

??linear    # Надяваме се да намерим някаква функция за линейна регресия. Намерихме я - stats::lm
help.search("anova")
??"linear model"

#       Начините за присвояване на обект към променлива са: "=", "<-" или "->". Последняит е 
#   напълно излишен но го има
x = 5
y <- 2*x + 6
"Austria" -> z
x;  y;  z


############################
#######
#######       О С Н О В Н И    С Т Р У К Т У Р И    О Т    Д А Н Н И
#######

#       1. Вектор/масив

#       Векторът в R е най-широко разпространената и основна структура от данни. Векторите
#   могат да бъдат два вида:
#       - atomic vector и
#       - list (лист)

#       1.1. Atomic vector съдържа най-често елементи от 5 основни типа:
#       - Числов - integer, Integer64, double, complex, numeric (съдържа integer и double);
#       - Стринг - character, factor (не принадлежи точно към типа стринг);
#       - Дата;
#       - Logical;
#       - Raw.

#       1.2. Лист (лист)
#       Листът е нещо като рекурсивен вектор, защото листът може да съдържа други листове
#   като елеменети в себе си.

#       ! Основната разлика между atomic vector и листът е, че векторът е хомогенен (съдържа
#   елементи от един тип), а листът е хетерогенен (съдържа елементи от различни типове).

#       Добре, да започваме.

#       С комaндата "c(...)" се създава вектор от елементи. 
v1 <- c()   #  Създаване на празен вектор
v1 <- c(1, 4, 6., 4, 7, 12., -17, 1)   #  Създаване на вектор, който съдържа числа
v1


v2 <- c("a", "b", "c")  # Създаване на стрингов вектор
v2


#       За да добавим нови елементи към вектора, най-лесно е да използваме отново 
#   командата "c(...)"
v1 <- c(v1, 99);  v1
v1 <- c(v1, 80);  v1


#       Вместо да прибавяме един по един елементи към вектора v1, можем направо да добавим
#   нов вектор, който съдържа всички елементи, които сме смятали добавим
v12 <- c(v1, v2)  #   Новият вектор съдържа елементите и на двата вектора v1 и v2  
v12 


#       - Ммм, като че ли има нещо странно в новия вектор "v12". 
#       - Не точно. Странноста се състои в това, че всички елементи на вектора v12 са
#   от стрингов тип. Но това е напълно в реда на нещата, понеже atomic vector-ът е 
#   хомогенен и е по-приемливо числата да бъдат превърнати от числов тип в стрингов,
#   отколкото обратното. Все пак "a" какво число е?


#       За да проверим типа на елементите в новия вектор има няколко възможности - функцията 
#   "str(...)" и "class(x)"
str(v1) #   Числов вектор
class(v1)

str(v2) #   Стрингов вектор
class(v2)

str(v12) #   Автоматично е cast-нат е до стрингов вектор


#         Добре, да разгледаме типа "дата". Нека да построим вектор с елемент от тип дата.
#   Възможностите са две - да изпозлваме стрингов или числов вектор, който да превърнем 
#   във вектор с дати.
#         С функцията "as.Date" конвертираме въпросния вектор във такъв, съдържащ дати.
?as.Date

v3 <- as.Date(c("2015-01-01", "2016-07-08"))
v3
str(v3)
class(v3)

#   или пък
as.Date(c("20150101", "20160708"), format = "%Y%m%d")

#   или пък
as.Date(c("01.01.2015", "08.07.2016"), format = "%d.%m.%Y")

#       Както се вижда, можем да използваме почти всякакъв вид стрингов запис, стига да
#   съдържа датата под формата на логика. За останалото се грижи параметърът "format".
#       Между другото "format" пробва някои стандартни шаблони за изписване на дати.


v13 <- c(v1, v3)
v13

str(v13)  #   Числов вектор   
#       Забележете, че датите са integer числа, които броят дните от 1970-01-01 до посочената 
#   дата. Ако годината е преди 1970-01-01, то стойността е отрицателна.
c(4, as.Date("1576-07-16"))



#       - А можем ли да кажем на R, че искаме непременно векторът да бъде в числов вид
#       - Да и не само в числов. Можем да му кажем, че искаме да го cast-нем в стрингов или 
#   във вектор, съдържащ дати (както направихме по-горе). Това, разбира се, може да доведе 
#   до загуба на информация.
as.numeric(v12)
#       Стойността "NA" в последните три елемента от вектора, показва, че имаме липса на 
#   информация. Това се дължи на факта, че се опитахме да представим стрингов вектор в 
#   числова форма.
as.character(v1)    
#   Тук нямаме проблем, защото всеки елемент може да се представи в стрингова форма.


#   Да пробваме да преобразуваме числов вектор във вектор с дати
as.Date(v1)
#       - Дава грешка. Защо? 
#       - Защото не сме посочили начална дата, от която да тръгне броенето на дните.  
#   Началната дата се задава с параметъра "origin"
as.Date(v1, origin = "2011-01-01")


as.Date(v1, origin = "2011-01-01")[which(v1 < 0)]
v1
#   Заради отрицателното число, датата е преди "2011-01-01".
#   функцията which ще я разгледаме по-нататък в курса.

v3; v3 + 7  #   към всяка една дата, добаваме 7 дена


#     Остана да разлгедаме вектори от тип logical.
v4 <- c(TRUE, FALSE, TRUE, T, F, FALSE)
v4
str(v4)
#   T == TRUE и F == FALSE


#     Нека да пробваме някои неща с logical вектор
v4*7
as.numeric(v4)
as.logical(c(-10, 3, 5, 0, exp(3)))
#     Вектор с елементи от логически тип се преобразува до числов вектор
v14 <- c(v1, v4)
v14;  str(v14)



#   length(...) - взима дължината на вектор
length(v1)



#           О П Е Р А Ц И И    С    В Е К Т О Р И

#           Взимане на елемент от вектор
v1[1]   #   Индексацията започва от 1
v1[c(1, length(v1))]    #   Нов вектор, който съдържа първия и последния елемент от вектора
v1[c(3, 3, 3, 3)]    #   Вектор, който има дължина 4 и стойностите му са третия елемент от v1
v1[rep(3, 4)] #  Еквивалентно на горния ред
#   rep(x, times) - създава вектор с дължина "times" и стойности x




1:8 #   Създаваме редица, която съдържа елементите от 1 до 8
8:1 #   Създаваме редица, която съдържа елементите от 8 до 1

#   Горните два реда са еквивалентни съответно на долните два
seq(from = 1, to = 8, by = 1)
seq(from = 8, to = 1, by = -1)

#   Искаме да вектор, който да съдържа 3, 6, 1, 2, 3, 4 елементи от вектора v1
v1[c(3, 6, 1:4)]

#   В R можем да създадем подвектор на v1, като му кажем кои стойности НЕ ИСКАМЕ да присъстват
v1[-c(3, 6)]
v1[-(3:6)]


#       Можем да добавяме/умножаваме с число даден вектор. Също така можем да събираме и 
#   умножаваме два вектора. 



#       За да не ни се налага да се чудим какви числа да измисляме всеки път, то най-добре е 
#   всичко до оставим в ръцете на "съдбата". Тоест да генерираме нашите числа на случаен 
#   принцип.
#       Създаваме 3 вектора с генерирани псевдослучайни величини. За да получаваме винаги 
#   една и съща редица от числа, то трябва винаги да стартираме от една и съща начална 
#   позиция. За тази цел използваме командата set.seed(...). 
#       Искаме числата, които се генерират в трите вектора, да се падат с равни вероятности. 
#   Тоест P(1) = P(2) = ... = P(n-1) = P(n), където P(x) е вероятнсотта да се падне числото x.
#      В упражненията ще учите подробно различните вероятностни разпределения, но за момента 
#   е достатъчно да знаем, че този вид разпределение се нарича "равномерно".

#   На долния ред е показан пример на равномерно разпределение
hist(trunc(runif(10^3, 1, 5.9999)), col = "red", main = "Histogram", 
     xlab = "Pseudo random numbers")



#
set.seed(1806) 
v4 <- trunc(runif(n = 20, min = 1, max = 40.99999))
set.seed(2713) 
v5 <- round(runif(n = length(v4), min = 1, max = 40.99999))
set.seed(189) 
v6 <- round(runif(n = length(v4) - 7, min = 1, max = 40.99999))

#         runif - функция за генериране на псевдо случайни равномерно разпределени числа.
#   Първият параметър е за броя на случайните числа. Вторият и третият показват обхвата на
#   възможните числа.
#       Препоръчвам да я разгледате, защото се използва при Монте Карло методите за оптимизации




v4 + 3
2*v4
v4/7 + 11

v4*v5   #   Скаларно произведение
v4*v6   
#       Дава предупреждение, защото дължината на втория вектор не е кратна на първия.
#   Ето защо започва умножението отначало до достигане на дължината на по-големия вектор.


#   - А друго какво мога да правя? Мога ли да сменям числа във вектора?
#   - Може, разбира се.
v4.prime <- v4


v4[c(1, 2, 3)] <- c(3, 2, 1)

v4 <- v4.prime
v4[c(1, 2, 3, 4)] <- c(100, -100)
#       ! И тук важи правилото за кратност между двата вектора.


#   -------
#       Функции
#   име_на_функцията <- function(параметри) {
#
#   }

func1 <- function(a, b, c) {
  return(a + b + c)
}

func1(1, 2, 3)


#   Функциите в R могат да имат стойности по подразбиране
func2 <- function(a, b = 0, c = 0) {
  return(a + b + c)
}

func2(1)
func2(1, 2)
func2(1, c = 3)
#   Функциите в R могат да приемат параметрите си в различен ред
func2(a = 1, c = 3, b = 2)

func2(b = 2, c = 3)
#   Връща грешка, защото не сме задали стойност по подразбиране на параметъра "a" във функцията
#   Това лесно може да се избегне с едно условие във функцията

func3 <- function(a, b = 0, c = 0) {
  if(missing(a)) {
    print("You don't enter value for \"a\". The function generate normal distributed value")
    a <- rnorm(n = 1)
  }
  return(a + b + c)
}
#      Командата "missing" проверява дали имаме стойност за параметъра "a"
#       С "print()" извеждаме съобщение
#       С "rnorm(n = 1)" генерираме една (n = 1) нормално разпределена случайна величина 
#   с очакване 0 и стандартно отклонение 1
func3(a = 1, b = 2, c = 3)
func3(b = 2, c = 3)


func4 <- function(a, b = 2, c = 3) {
  if(missing(a)) {a <- NA}
  Obj <- NULL
  Obj$number1 <- a
  Obj[["number2"]] <- b
  Obj$number3 <- c
  
  Obj # return(Obj)
}

func4(1, 2, 3)


#   if-else условия
# if() {
#     
# } else if() {
#     
# } else {
#     
# }

A <- 5
if(A < 5) {
  print("A is smaller than 5")
} else if(A == 5) {
  print("A is equal to 5")
} else {
  print("A is greater than 5")
}




#   Цикли
#       for(...) {}
#       Цикълът for представлява foreach итерация. Конструкцията е проста - 
#   променлива %in% вектор
v7 <- c("a", "b", "c", "d", "e") 
for(i in v7) {print(i)}


for(i in 1:length(v7)) {print(v7[i])}
for(i in seq(from = 1, to = length(v7), by =1)) {print(v7[i])}
for(i in length(v7):1) {print(v7[i])}


for(i in 1:length(v7)) {
  if(i == 4) {
    print("----MISS")
    next
  }
  print(v7[i])
  
}
#   С командата "next" пропускаме итерация


counter <- 0
while(counter < 5) {
  counter <- counter + 1
  print(counter)
}


# do - while
counter <- 0
repeat {
  counter <- counter + 1
  print(counter)
  
  if(counter > 5) {
    break
  }
}
#   С командата "break" излизаме от най-близкия цикъл


#       Циклите в R са бавни. Ето защо е подходящо в някои случаи да използвате методите
#   apply, lapply, sapply, vapply и tapply. Тези методи ще ги представим след малко.



#       2. Матрица
#       С функцията "matrix" в R създаваме матрица от предварително зададено множество от
#   стойности - вектор или лист със стойности. Освен множеството с елементи, трябва да 
#   посочим и формата на матрицата - брой редове и колони. Стойностите на матрицата се 
#   пълнят по колони. За да напълним матрицата със стойности по редове, трябва да използваме
#   параметъра byrow = TRUE


l_0 <- lapply(X = 1:12, FUN = function(x) {x^2})
l_0
l_0[1] + 5
str(l_0[1])


l_0[[1]]
l_0[[1]] + 5
str(l_0[[1]])




l1 <- lapply(X = 1:12, FUN = function(x) {x}) #  лист
M1 <- matrix(data = l1, nrow = 4, ncol = 3)
M1 <- matrix(data = 1:12, nrow = 4, ncol = 3)
#   Горните два реда са еквивалентни
M2 <- matrix(data = 1:12, nrow = 4, ncol = 3, byrow = T)



M1
M2


#       Взимане на елемент, ред, колона и подматрица от матрица
M3 <- matrix(data = c(1:28), nrow = 7, ncol = 4, byrow = TRUE)
M3[2, ]   #   Взимане на ред
M3[, 3]   #   Взимане на цолона
M3[1, 3]  #   Взимане на елемент
M3[c(1, 2), 3]  #   Взимаме 1 и 2 елемент от 3 колона
M3[c(1, 2), c(3, 4)]  #   Взимаме подматрица

#       Операции с матрици
M3 + 4  #   Добавяме число към матрицата
M3 + 5*c(1:7) #   Добавяме по вектор към всеки от четирите колони


#   Аналогично е и при умножение на матрица с вектор


M4 <- matrix(1:8, nrow = 4, ncol = 2)
M34 <- M3 %*% M4   #   Стандартно умножение на две матрици
M34
#   M(7x4) * M(4x2) = M(7x2)

dim(M34)    #   Връща размера на матрицата
nrow(M34)   #   Връща броя на редовете
ncol(M34)   #   Връща броя на колоните


#       Функцията apply се прилага върху матрици, data.frame и други производни структури. 
#       Първият параметър е множеството от данни, вторият показва по редове (1) или 
#   колони (2) искаме да направим трансформациите, а третият е самата функция


#   Сумиране на елементите по редове
apply(X = M3, MARGIN = 1, FUN = sum)    
#   Сумиране на повдигнатите на квадрат елементи по редове
apply(X = M3, MARGIN = 1, FUN = function(x) {sum(x^2)}) 
#   Сумиране на повдигнатите на квадрат и разделени на "a"елементи по редове
apply(X = M3, MARGIN = 1, FUN = function(x, a) {sum((x^2) / a)})
#   Този пример дава грешка, защото параметърът "a" липсва


apply(X = M3, MARGIN = 1, 
      FUN = function(x, a) {sum((x^2) / a)},
      a = 4)
#   Добавяме параметър "а" към функцията apply

#   При горния пример видяхме, че може да се използват по-сложни фунцкии от стандартните


#   Сумиране на елементите в матрицата по колони
apply(X = M3, MARGIN = 2, FUN = sum)



#       3. Data frame
#       Друга структура за съхраняване на данни в R е data frame. Разликата с матрицата е, 
#   че елементите в матрицата е вектор от вектори и всички елементи са от един тип, докато
#   data frame-a е лист от вектори и елементите на data frame-а са от един тип, само в рамките 
#   на отделния вектор.


car_brand <- c('volkswagen', 'chevrolet', 'peugot', 'volvo', 'porsche', 'chevrolet', 'mitsubishi', 'mazda', 
               'toyota', 'subaru', 'isuzu', 'volvo', 'mercury', 'honda', 'peugot', 'porsche', 'dodge', 
               'volkswagen', 'bmw', 'mercedes-benz', 'toyota', 'isuzu', 'volkswagen', 'mazda', 'plymouth', 
               'honda', 'mitsubishi', 'plymouth', 'volkswagen', 'volkswagen', 'honda', 'toyota', 'nissan', 
               'nissan', 'mitsubishi', 'volvo', 'toyota', 'jaguar', 'volkswagen', 'dodge')
fuel_type <- c('gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 
               'gas', 'gas', 'gas', 'gas', 'gas', 'gas', 'diesel', 'gas', 'gas', 'diesel', 'gas', 'gas', 'gas', 
               'gas', 'diesel', 'gas', 'gas', 'gas', 'gas', 'diesel', 'gas', 'gas', 'gas', 'gas', 'gas', 'gas')
horsepower <- c(111, 154, 102, 115, 110, 140, 160, 101, 121, 182, 48, 70, 68, 102, 88, 145, 58, 76, 60, 86, 
                101, 100, 78, 70, 90, 176, 262, 68, 101, 135, 84, 64, 120, 72, 123, 155, 184, 175, 68, 102)
turbo_aspiration <- c(FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, 
                      FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, 
                      FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE)
date <- c('2019-01-09', '2019-03-01', '2019-01-16', '2018-12-13', '2019-02-16', '2019-02-15', '2019-02-19', 
          '2019-02-27', '2019-01-19', '2019-01-22', '2019-03-05', '2018-12-19', '2019-01-13', '2019-02-04', 
          '2019-01-30', '2019-01-12', '2019-02-28', '2018-12-15', '2018-12-31', '2018-12-20', '2019-01-21', 
          '2019-01-24', '2019-02-05', '2019-02-17', '2018-12-19', '2018-12-26', '2019-02-26', '2018-12-26', 
          '2018-12-19', '2018-12-17', '2019-03-04', '2019-03-07', '2019-01-26', '2019-02-06', '2018-12-20', 
          '2018-12-13', '2018-12-15', '2018-12-24', '2018-12-30', '2019-03-03')
cars <- data.frame(
  date = as.Date(date),			#	Дати
  car_brand, fuel_type,		#	Стрингове
  turbo_aspiration,	#	Булева променлива
  horsepower	#	Числа
) 


rm(list = c("car_brand", "fuel_type", "horsepower", "turbo_aspiration", "date"))
#   rm(list = setdiff(ls(), c("cars")))

# функцията rm() премахва обектите, които описани в масива, присвоен на параметъра "list"

ls()


str(cars)
#       Както виждаме, data frame-а може да съдържа данни от различен тип - дата, стринг, 
#   булев или числов.


#
#       В R можем да вземем първите и последните няколко реда с помощта на функциите head() и tail()
head(x = cars)
head(x = cars, n = 3)	#	n - колко наблюдения искаме да видим. По подразбиране, стойността на n е 6
tail(x = cars, n = 3)




#       Функциите apply, lapply, sapply и т.н. могат да се прилагат и върху data frame-ове



#       Взимане на ред, колона и елемент от data frame
#       Всеки от начините, които споменахме при взиамне на елементи от матрица, са приложими и 
#   за data frame, като отделно имаме и допълнителни.

#	dataframe[избор на редове, избор на колони]

cars[1, ]	#	Първи ред и всички колони (индексът за колоните е празен)

cars[, 2]	#	Втора колона и всички редове (индексът за редовете е празен)
cars[1:nrow(cars), 2]	#	еквивалентен на горния ред

cars[5, c(2, 3)]	#	Пети ред, втора и трета колона
cars[5, 4]	#	5 ред и 4-та колона


#	С функцията row.names можем както да взимаме имената на редовете, така можем и да променяме вече съществуващи имена

row.names(cars)

row.names(cars) <- paste("car", row.names(cars), sep = "_")
#	С paste() обединяваме вектори със стрингове (n-тия елемент на единия вектор с n-тия елемент на друг вектор)
#   Имената трябва да са уникални


#       При data frame-а можем да вземем елементи и посредством техните имена
#   - по колони
cars$car_brand		#	С "$" взимаме елементи от листа. Data frame-а е ЛИСТ от ВЕКТОРИ => взимаме вектора
cars[, "car_brand"]
#   Еквивалентни са на cars[, 2]


#   - по редове
cars["car_1", ]
#   Еквивалентхно е на cars[1, ]

#   - по редове и колони
cars["car_1", c("car_brand", "turbo_aspiration")]




#       Следващата стъпка е филтрирането на данни и взимането на подгрупи по зададен признак
#	& - логическо "и", | - логическо "или", == - проверка за равенстов 
#   which() - Връща вектор с индекстите на елементите, за които булевото условие връща TRUE.
#	Тоест взимаме индексите на елементите, които ни вълнуват по някакъв начин.

#       Нека да проверим кои от всички 40 модела коли имат turbo aspiration.
which(cars$turbo_aspiration)
cars[which(cars$turbo_aspiration), ]	#	Извеждаме самите наблюдения
#		cars$turbo_aspiration е булева променлива => which(cars$turbo_aspiration) ще ни върне индексите 
#	на наблюденията, които изпълняват това условие => имайки индексите с cars[индексите, ], 
#	извеждаме и самите резултати
cars[which(cars$turbo_aspiration), "car_brand"] #	Имената на момичетата, които са приели
cars$car_brand[which(cars$turbo_aspiration)]

cars$horsepower >= 120
cars[which(cars$horsepower >= 120), ]   #   коли, които имат над 102 конски сили
#		Векторът cars$horsepower съдържа стойностите 111, 154, 102, 115, ..., 184, 175, 68, 102.
#	С условието cars$horsepower >= 102 ще върне T, T, T, T, ..., F, T, T, T, T, F, T =>
#	which(cars$horsepower >= 102) ще върне вектор с индекси 1, 2, 3, 4, 5, 6, ..., 36, 37 38, 40 =>
#	cars[which(cars$horsepower >= 102), ] ще върне информацията за колите, които имат конски сили поне 102


cars$car_brand %in% c("chevrolet", "porsche")
cars[which(cars$car_brand %in% c("chevrolet", "porsche")), ]
#       първи/а масив/вектор/лист/стойност %in% втори/а масив/вектор/лист/стойност - 
#   проверяваме кои елементи от първата структура присъстват във втората.


cars[which((cars$car_brand %in% c("chevrolet", "porsche")) &
             cars[, "horsepower"] > 140), ]


cars[which((cars$car_brand %in% c("chevrolet", "porsche")) |
             cars[, "horsepower"] > 170), ]


#       Как да вземем моделите на колите, които имат turbo aspiration и са продадени
#   през последната седмица? Дали са има такива?






#       Обединяване на матрици и data frame-ове по редове и колони

#       Ще покажем случая с матрици. С data frame е абсолютно същото.
#       Създаваме две матрици
M1 <- matrix(data = 1:20, nrow = 10, byrow = T)
M2 <- matrix(data = 21:30, nrow = 2, byrow = T)
M1; M2


#       Функциите за обединяване на две матрици/data frame-ове са:
#   - rbind - обединение по редове - долепя втората матрица под първата
#   - cbind - обединение по колони - долепя втората матрица след първата
rbind(M1, M2)   
#       Връща грешка, защото, когато обединяваме две матрици по редове, то размерът на 
#   колоните трябва да бъде еднакъв. Същото се отнася и при обединяване по колони - 
#   искаме редовете да са еднавни на брой.
#       Проверка може да се извърши с nrow(), ncol() и dim()

dim(M1)
dim(M2)

#       Нека да транспонираме втората матрица (транспонирането е операция, за която редовете се
#   превръщат в колони). Функцията за транспониране в R е t()
M2.t <- t(M2)
dim(M2.t)

rbind(M1, M2.t)

#   Пример за обединение по колони
M3 <- matrix(data = 21:40, nrow = 10, byrow = T)
cbind(M1, M3)






attach(cars)
car_brand
detach(cars)
car_brand



#       С това приключваме с въведението за трите типа структури данни в R.





#       ЗАДАЧИ ЗА УПРАЖНЕНИЕ:

#         ЗАДАЧА 1. Намиране на коефициенти на проста линейна регресия в няколко стъпки
#     1.1. Създайте вектор с коефициенти на име BETA със стойности 3 и 10
#     1.2. Създайте матрица M с размер 20 на 2 от вектор X
X <- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.12, 0.17, 
       0.13, 0.89, 0.51, 0.96, 0.33, 0.38, 0.21, 0.84, 0.68, 0.29, 0.84, 0.94, 
       0.79, 0.99, 0.34, 0.97, 0.04, 0.87)
#     1.3. Създайте вектор Y като сумирате умножение на елементите от двата вектора 
# BETA с всеки ред от матрицата M. Можете да използвате цикъл или apply.
#     1.4. Към вектора Y добавете вектора 0.3*NOISE
set.seed(9907)
NOISE <- rnorm(20)  #   ! Погледнете какво прави функцията "rnorm"
#     1.5. Напишете финкция "estim_F", която, приема четири параметъра - 
# y (вектор), x (вектор), a (скалар) и b (скалар)
#     На параметъра "x" се присвоява втората колона от M
#     В тялото на функцията:
#       - първо се изчислява вектор "prediction" по формулата a + b*x. 
#       - после се изчислява вектор "resid" по формулата y - prediction.
#       - следваща стъпка е векторът "resid" да се вдигне на квадрат и да се сумират 
# стойностите на новополучения вектор. Това е и стойността, която функцията
# трябва да се върне
#     1.6. За наредените двойки (a, b) = (1, 2), (-3, 17), (2.9, 9.7), (3.2, 10.1)
# определете, тази, за която стойността на функцията е най-малка.

#     Честито. Току-що направихте първата си оптимизационна задача за изчисляване 
# на линеен модел.




BETA = c(3, 10)
M <- matrix(data = X, nrow = 20, ncol = 2)
Y <- apply(M, 1, FUN = function(x, a) {sum(a*x)}, a = BETA) + 0.3*NOISE

estim_F <- function(y, x, a, b) {
  prediction <- a + b*x
  resid <- y - prediction
  return(sum(resid^2))
}

estim_F(y = Y, x = M[, 2], a = 1, b = 2)
estim_F(y = Y, x = M[, 2], a = -3, b = 17)
estim_F(y = Y, x = M[, 2], a = 2.9, b = 9.7)
estim_F(y = Y, x = M[, 2], a = 3.2, b = 10.1)



#       ЗАДАЧА 2. Mann-Kendall test (непараметричен тест за изследване на монотонен тренд)
#   За последните 3 години, месечните цени на акциите на компания AAA са:


#       Ще използваме направо библиотека, за да смъкнем реални цени на някоя от компаниите
#   

library(quantmod)   #     Ако нямате пакета "`quantmod", инсталирайте си го. 

SYMBOL <- "AAPL"
FROM <- "2017-01-01"
TO <- "2020-01-01"
AAA <- getSymbols(Symbols = SYMBOL, src = "yahoo", periodicity = "monthly",
                  from = FROM, to = TO, auto.assign = FALSE)
AAA <- AAA[, which(grepl(pattern = "adjusted$", x = names(AAA), ignore.case = TRUE))]
AAA <- as.vector(AAA)
#     Symbols - име на компанията
#     src - откъде да ги смъкнем


#       Ако по някаква странна причина не можем да смъкнем реалните цени на компанията,
#   ще използваме долния ред.
AAA <- c(102.35, 107.17, 110.61, 88.51, 110.12, 113.63, 118.56, 119.14, 125.4, 
         109.7, 128.46, 120.18, 124.75, 144.62, 127.57, 122.04, 148.32, 137.04, 
         156.42, 141.62, 138.75, 157.16, 143.16, 152.92, 146.83, 147.38, 135.68, 
         143.28, 164.35, 166.6, 169.11, 154.6, 169.48, 167, 163.21, 171.84)
#   Ползата от разработването на такъв тест е, че ако имаме възходящ или низходящ
# тренд, то може да се възползваме от знанието си.
#   Защото ... "Знанието не е сила, прилагането му обаче е"

#     2.1. С помощта на двоен цикъл трябва всеки един елемент от вектора (без 
#   последния елемент) да се сравни с всички следващи елементи. Тоест:
#     AAA[1] да се сравни с AAA[2], AAA[3], ..., AAA[36],
#     AAA[2] да се сравни с AAA[3], AAA[4], ..., AAA[36] 
#     и т.н., докато не стигнем до AAA[31], където AAA[31] сравняваме с AAA[32]
#   при сравняването трябва да използваме функцията sign(ААА[i] - AAA[j]), където
#   j > i
#     Получените сравнения ги добавяме към променливата S 
#   (S = S + sign(ААА[i] - AAA[j]))
#     2.2. Изчислете стойността sigma2 = (n*(n - 1)*(2*n + 5)) / 18, където
#   n е броят на наблюденията във вектора. За изчисленията ни трябва 
#   корен квадратен от sigma2, която стойност ще я присвоим на "sigma"

#     2.3. Създаваме променливата Z, за която:
#       aко S < 0, Z = (S + 1)/sigma
#       aко S = 0, Z = 0
#       aко S > 0, Z = (S - 1)/sigma

#   Без много да навлизаме в подробности, ако Z > 2, имамв възходящ тренд. Ако
# Z < -2, то имаме низходящ тренд. В останалия случай Z: [-2, 2], не можем да
# кажем нищо.


?sign
sign(x = 3);  sign(x = -6886);  sign(x = 0)
#		Функцията връща една от трите стойности (-1, 0, 1) съответно, ако стойността
#	на x е по-голяма, равна, по-малка на 0


n <- length(AAA)
S <- 0
for(i1 in 1:(n - 1)) {
  for(i2 in (i1 + 1):n) {
    S = S + sign(AAA[i2] - AAA[i1])
  }
}

sigma2 <- (n*(n - 1)*(2*n + 5)) / 18
sigma <- sqrt(sigma2)

Z <- 0
if(S < 0) {
  Z <- (S + 1) / sigma
} else if(S == 0) {
  Z <- 0
} else {
  Z <- (S - 1) / sigma
}

Z

#       Нека да проверим нагледно, дали сме прави
plot(AAA, type = "o", ylab = "Price")



#       Ако боравим с истински цени, можем да проверим за една година напред 
#   какво е станало. Да проверим дали статистическите тестове работя.

TO1 <- "2021-01-01"
AAA1 <- getSymbols(Symbols = SYMBOL, src = "yahoo", periodicity = "monthly",
                   from = FROM, to = TO1, auto.assign = FALSE)
AAA1 <- AAA1[, which(grepl(pattern = "adjusted$", x = names(AAA1), ignore.case = TRUE))]
AAA2 <- AAA1 <- as.vector(AAA1)
AAA2[1:(length(AAA) - 1)] <- NA


plot(c(AAA, rep(NA, length(AAA1) - length(AAA))), type = "o", ylab = "Price", 
     ylim = range(AAA1), main = SYMBOL)
lines(AAA2, col = "red", lty = 2)